{"pageProps":{"packageRepo":{"package":{"id":"better-typography-0.1.3","name":"better-typography","author":"Justin Wayne Liles","description":"A package to help convert quotes into smart quotes.","title":"Better Typography","version":"0.1.3","tags":["typography","quotes","convert","replacement"],"archive_url":"https://github.com/espanso/hub/releases/latest/download/better-typography-0.1.3.zip","archive_sha256_url":"https://github.com/espanso/hub/releases/latest/download/better-typography-0.1.3-sha256.txt"},"manifest":{"name":"better-typography","title":"Better Typography","description":"A package to help convert quotes into smart quotes.","version":"0.1.3","author":"Justin Wayne Liles","tags":["typography","quotes","convert","replacement"],"homepage":{"_tag":"Some","value":"https://github.com/jwliles/better-typography"}},"readme":"# Better Typography\n\nThis is an Espanso package to help with converting quotes into smart quotes. I\ncreated the file when I realized I had extensions or plugins in multiple apps\nmeant to assist with these conversions. It is inspired by the [Smart Typography](https://github.com/mgmeyers/obsidian-smart-typography)\nplugin for Obsidian by mgmeyers.\n\n## Replacements\n\n*NOTE:* The pipe character is the cursor position.\n\n| Trigger | Replacement | Character                |\n|---------|-------------|--------------------------|\n| ,\"      | “$\\|$”      | smart quotes             |\n| ,'      | ‘$\\|$’      | single smart quote       |\n| ''      | ’           | unicode apostrophe       |\n| ,n      | –           | en dash                  |\n| ,m      | —           | em dash                  |\n| ...     | …           | ellipsis                 |\n| <<      | «           | open guillemet           |\n| >>      | »           | close guillemet          |\n| <-      | ←           | left arrow               |\n| ->      | →           | right arrow              |\n| <=      | ≤           | less than or equal to    |\n| >=      | ≥           | greater than or equal to |\n| /=      | ≠           | not equal                |\n","packageYml":[{"name":"package.yml","content":"matches:\n  - trigger: ';\"'\n    replace: \"“$|$”\"\n\n  - trigger: \";'\"\n    replace: \"‘$|$’\"\n\n  - trigger: \"''\"\n    replace: \"’\"\n\n  - trigger: \";;n\"\n    replace: \"–\"\n\n  - trigger: \";;m\"\n    replace: \"—\"\n\n  - trigger: '...'\n    replace: '…'\n\n  - trigger: ';<<'\n    replace: '«'\n\n  - trigger: ';>>'\n    replace: '»'\n\n  - trigger: ';<-'\n    replace: '←'\n\n  - trigger: ';->'\n    replace: '→'\n\n  - trigger: ';<='\n    replace: '≤'\n\n  - trigger: ';>='\n    replace: '≥'\n\n  - trigger: ';/='\n    replace: '≠'\n\n  - regex: '(?P<num1>\\d+)/(?P<num2>\\w+ )'\n    replace: \"{{num1}}⁄{{num2}}\"\n"}],"license":{"_tag":"None"},"serializedReadme":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Better Typography\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is an Espanso package to help with converting quotes into smart quotes. I\\ncreated the file when I realized I had extensions or plugins in multiple apps\\nmeant to assist with these conversions. It is inspired by the \", _jsx(_components.a, {\n        href: \"https://github.com/mgmeyers/obsidian-smart-typography\",\n        children: \"Smart Typography\"\n      }), \"\\nplugin for Obsidian by mgmeyers.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Replacements\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"NOTE:\"\n      }), \" The pipe character is the cursor position.\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Trigger\"\n          }), _jsx(_components.th, {\n            children: \"Replacement\"\n          }), _jsx(_components.th, {\n            children: \"Character\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \",\\\"\"\n          }), _jsx(_components.td, {\n            children: \"“$|$”\"\n          }), _jsx(_components.td, {\n            children: \"smart quotes\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \",'\"\n          }), _jsx(_components.td, {\n            children: \"‘$|$’\"\n          }), _jsx(_components.td, {\n            children: \"single smart quote\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"''\"\n          }), _jsx(_components.td, {\n            children: \"’\"\n          }), _jsx(_components.td, {\n            children: \"unicode apostrophe\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \",n\"\n          }), _jsx(_components.td, {\n            children: \"–\"\n          }), _jsx(_components.td, {\n            children: \"en dash\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \",m\"\n          }), _jsx(_components.td, {\n            children: \"—\"\n          }), _jsx(_components.td, {\n            children: \"em dash\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"...\"\n          }), _jsx(_components.td, {\n            children: \"…\"\n          }), _jsx(_components.td, {\n            children: \"ellipsis\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"<<\"\n          }), _jsx(_components.td, {\n            children: \"«\"\n          }), _jsx(_components.td, {\n            children: \"open guillemet\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \">>\"\n          }), _jsx(_components.td, {\n            children: \"»\"\n          }), _jsx(_components.td, {\n            children: \"close guillemet\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"<-\"\n          }), _jsx(_components.td, {\n            children: \"←\"\n          }), _jsx(_components.td, {\n            children: \"left arrow\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"->\"\n          }), _jsx(_components.td, {\n            children: \"→\"\n          }), _jsx(_components.td, {\n            children: \"right arrow\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"<=\"\n          }), _jsx(_components.td, {\n            children: \"≤\"\n          }), _jsx(_components.td, {\n            children: \"less than or equal to\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \">=\"\n          }), _jsx(_components.td, {\n            children: \"≥\"\n          }), _jsx(_components.td, {\n            children: \"greater than or equal to\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"/=\"\n          }), _jsx(_components.td, {\n            children: \"≠\"\n          }), _jsx(_components.td, {\n            children: \"not equal\"\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"versions":["0.1.3"]},"__N_SSG":true}